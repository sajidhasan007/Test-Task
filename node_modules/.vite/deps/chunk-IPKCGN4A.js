import {
  CSS,
  add,
  canUseDOM,
  subtract,
  useInterval,
  useIsomorphicLayoutEffect,
  useLazyMemo,
  useNodeRef,
  useUniqueId
} from "./chunk-U2XPFEWA.js";
import {
  require_react_dom
} from "./chunk-75TOF7WX.js";
import {
  __toESM,
  require_react
} from "./chunk-OMFGQDFA.js";

// node_modules/@dnd-kit/core/dist/core.esm.js
var import_react2 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js
var import_react = __toESM(require_react());
var hiddenStyles = {
  display: "none"
};
function HiddenText(_ref) {
  let {
    id,
    value
  } = _ref;
  return import_react.default.createElement("div", {
    id,
    style: hiddenStyles
  }, value);
}
var visuallyHidden = {
  position: "fixed",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  clipPath: "inset(100%)",
  whiteSpace: "nowrap"
};
function LiveRegion(_ref) {
  let {
    id,
    announcement
  } = _ref;
  return import_react.default.createElement("div", {
    id,
    style: visuallyHidden,
    role: "status",
    "aria-live": "assertive",
    "aria-atomic": true
  }, announcement);
}
function useAnnouncement() {
  const [announcement, setAnnouncement] = (0, import_react.useState)("");
  const announce = (0, import_react.useCallback)((value) => {
    if (value != null) {
      setAnnouncement(value);
    }
  }, []);
  return {
    announce,
    announcement
  };
}

// node_modules/@dnd-kit/core/dist/core.esm.js
var screenReaderInstructions = {
  draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `
};
var defaultAnnouncements = {
  onDragStart(id) {
    return `Picked up draggable item ${id}.`;
  },
  onDragOver(id, overId) {
    if (overId) {
      return `Draggable item ${id} was moved over droppable area ${overId}.`;
    }
    return `Draggable item ${id} is no longer over a droppable area.`;
  },
  onDragEnd(id, overId) {
    if (overId) {
      return `Draggable item ${id} was dropped over droppable area ${overId}`;
    }
    return `Draggable item ${id} was dropped.`;
  },
  onDragCancel(id) {
    return `Dragging was cancelled. Draggable item ${id} was dropped.`;
  }
};
var Action;
(function(Action2) {
  Action2["DragStart"] = "dragStart";
  Action2["DragMove"] = "dragMove";
  Action2["DragEnd"] = "dragEnd";
  Action2["DragCancel"] = "dragCancel";
  Action2["DragOver"] = "dragOver";
  Action2["RegisterDroppable"] = "registerDroppable";
  Action2["SetDroppableDisabled"] = "setDroppableDisabled";
  Action2["UnregisterDroppable"] = "unregisterDroppable";
})(Action || (Action = {}));
var getMaxValueIndex = (array) => getValueIndex(array, (value, tracked) => value > tracked);
var getMinValueIndex = (array) => getValueIndex(array, (value, tracked) => value < tracked);
function getValueIndex(array, comparator) {
  if (array.length === 0) {
    return -1;
  }
  let tracked = array[0];
  let index = 0;
  for (var i = 1; i < array.length; i++) {
    if (comparator(array[i], tracked)) {
      index = i;
      tracked = array[i];
    }
  }
  return index;
}
function noop(..._args) {
}
function omit(id, elements) {
  const {
    [id]: _,
    ...other
  } = elements;
  return other;
}
var Context = (0, import_react2.createContext)({
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  activeNodeClientRect: null,
  activators: [],
  ariaDescribedById: {
    draggable: ""
  },
  containerNodeRect: null,
  dispatch: noop,
  draggableNodes: {},
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: {},
  over: null,
  overlayNode: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: noop
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  recomputeLayouts: noop,
  windowRect: null,
  willRecomputeLayouts: false
});
var defaultCoordinates = Object.freeze({
  x: 0,
  y: 0
});
function distanceBetween(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function isTouchEvent(event) {
  var _window;
  return ((_window = window) == null ? void 0 : _window.TouchEvent) && event instanceof TouchEvent;
}
function isMouseEvent(event) {
  var _window;
  return ((_window = window) == null ? void 0 : _window.MouseEvent) && event instanceof MouseEvent || event.type.includes("mouse");
}
function getEventCoordinates(event) {
  if (isTouchEvent(event)) {
    if (event.touches && event.touches.length) {
      const {
        clientX: x,
        clientY: y
      } = event.touches[0];
      return {
        x,
        y
      };
    } else if (event.changedTouches && event.changedTouches.length) {
      const {
        clientX: x,
        clientY: y
      } = event.changedTouches[0];
      return {
        x,
        y
      };
    }
  }
  if (isMouseEvent(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return {
    x: 0,
    y: 0
  };
}
function getRelativeTransformOrigin(event, rect) {
  if (event instanceof KeyboardEvent) {
    return "0 0";
  }
  const eventCoordinates = getEventCoordinates(event);
  const transformOrigin = {
    x: (eventCoordinates.x - rect.left) / rect.width * 100,
    y: (eventCoordinates.y - rect.top) / rect.height * 100
  };
  return `${transformOrigin.x}% ${transformOrigin.y}%`;
}
function centerOfRectangle(rect, left = rect.offsetLeft, top = rect.offsetTop) {
  return {
    x: left + rect.width * 0.5,
    y: top + rect.height * 0.5
  };
}
var closestCenter = (rects, rect) => {
  const centerRect = centerOfRectangle(rect, rect.left, rect.top);
  const distances = rects.map(([_, rect2]) => distanceBetween(centerOfRectangle(rect2), centerRect));
  const minValueIndex = getMinValueIndex(distances);
  return rects[minValueIndex] ? rects[minValueIndex][0] : null;
};
function adjustScale(transform, rect1, rect2) {
  return {
    ...transform,
    scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
    scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
  };
}
function getRectDelta(rect1, rect2) {
  return rect1 && rect2 ? {
    x: rect1.left - rect2.left,
    y: rect1.top - rect2.top
  } : defaultCoordinates;
}
function createRectAdjustmentFn(modifier) {
  return function adjustViewRect(viewRect, ...adjustments) {
    return adjustments.reduce((acc, adjustment) => ({
      ...acc,
      top: acc.top + modifier * adjustment.y,
      bottom: acc.bottom + modifier * adjustment.y,
      left: acc.left + modifier * adjustment.x,
      right: acc.right + modifier * adjustment.x,
      offsetLeft: acc.offsetLeft + modifier * adjustment.x,
      offsetTop: acc.offsetTop + modifier * adjustment.y
    }), {
      ...viewRect
    });
  };
}
var getAdjustedRect = createRectAdjustmentFn(1);
function isScrollable(node) {
  const computedStyle = window.getComputedStyle(node);
  const overflowRegex = /(auto|scroll|overlay)/;
  const properties = ["overflow", "overflowX", "overflowY"];
  return properties.find((property) => {
    const value = computedStyle[property];
    return typeof value === "string" ? overflowRegex.test(value) : false;
  }) != null;
}
function getScrollableAncestors(element) {
  const scrollParents = [];
  function findScrollableAncestors(node) {
    if (!node) {
      return scrollParents;
    }
    if (node instanceof Document && node.scrollingElement != null) {
      scrollParents.push(node.scrollingElement);
      return scrollParents;
    }
    if (!(node instanceof HTMLElement) || node instanceof SVGElement) {
      return scrollParents;
    }
    if (isScrollable(node)) {
      scrollParents.push(node);
    }
    return findScrollableAncestors(node.parentNode);
  }
  return element ? findScrollableAncestors(element.parentNode) : scrollParents;
}
function getScrollableElement(element) {
  if (!canUseDOM) {
    return null;
  }
  if (element === document.scrollingElement || element instanceof Document) {
    return window;
  }
  if (element instanceof HTMLElement) {
    return element;
  }
  return null;
}
function getScrollCoordinates(element) {
  if (element instanceof Window) {
    return {
      x: element.scrollX,
      y: element.scrollY
    };
  }
  return {
    x: element.scrollLeft,
    y: element.scrollTop
  };
}
var Direction;
(function(Direction2) {
  Direction2[Direction2["Forward"] = 1] = "Forward";
  Direction2[Direction2["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));
function getScrollPosition(scrollingContainer) {
  const minScroll = {
    x: 0,
    y: 0
  };
  const maxScroll = {
    x: scrollingContainer.scrollWidth - scrollingContainer.clientWidth,
    y: scrollingContainer.scrollHeight - scrollingContainer.clientHeight
  };
  const isTop = scrollingContainer.scrollTop <= minScroll.y;
  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
  return {
    isTop,
    isLeft,
    isBottom,
    isRight,
    maxScroll,
    minScroll
  };
}
function isDocumentScrollingElement(element) {
  if (!canUseDOM || !element) {
    return false;
  }
  return element === document.scrollingElement;
}
var defaultThreshold = {
  x: 0.2,
  y: 0.2
};
function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, {
  top,
  left,
  right,
  bottom
}, acceleration = 10, thresholdPercentage = defaultThreshold) {
  const {
    clientHeight,
    clientWidth
  } = scrollContainer;
  const finalScrollContainerRect = isDocumentScrollingElement(scrollContainer) ? {
    top: 0,
    left: 0,
    right: clientWidth,
    bottom: clientHeight,
    width: clientWidth,
    height: clientHeight
  } : scrollContainerRect;
  const {
    isTop,
    isBottom,
    isLeft,
    isRight
  } = getScrollPosition(scrollContainer);
  const direction = {
    x: 0,
    y: 0
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold = {
    height: finalScrollContainerRect.height * thresholdPercentage.y,
    width: finalScrollContainerRect.width * thresholdPercentage.x
  };
  if (!isTop && top <= finalScrollContainerRect.top + threshold.height) {
    direction.y = Direction.Backward;
    speed.y = acceleration * Math.abs((finalScrollContainerRect.top + threshold.height - top) / threshold.height);
  } else if (!isBottom && bottom >= finalScrollContainerRect.bottom - threshold.height) {
    direction.y = Direction.Forward;
    speed.y = acceleration * Math.abs((finalScrollContainerRect.bottom - threshold.height - bottom) / threshold.height);
  }
  if (!isRight && right >= finalScrollContainerRect.right - threshold.width) {
    direction.x = Direction.Forward;
    speed.x = acceleration * Math.abs((finalScrollContainerRect.right - threshold.width - right) / threshold.width);
  } else if (!isLeft && left <= finalScrollContainerRect.left + threshold.width) {
    direction.x = Direction.Backward;
    speed.x = acceleration * Math.abs((finalScrollContainerRect.left + threshold.width - left) / threshold.width);
  }
  return {
    direction,
    speed
  };
}
function getScrollElementRect(element) {
  if (element === document.scrollingElement) {
    const {
      innerWidth,
      innerHeight
    } = window;
    return {
      top: 0,
      left: 0,
      right: innerWidth,
      bottom: innerHeight,
      width: innerWidth,
      height: innerHeight
    };
  }
  const {
    top,
    left,
    right,
    bottom
  } = element.getBoundingClientRect();
  return {
    top,
    left,
    right,
    bottom,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getScrollOffsets(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return add(acc, getScrollCoordinates(node));
  }, defaultCoordinates);
}
function getEdgeOffset(node, parent, offset = defaultCoordinates) {
  if (!node || !(node instanceof HTMLElement)) {
    return offset;
  }
  const nodeOffset = {
    x: offset.x + node.offsetLeft,
    y: offset.y + node.offsetTop
  };
  if (node.offsetParent === parent) {
    return nodeOffset;
  }
  return getEdgeOffset(node.offsetParent, parent, nodeOffset);
}
function getElementLayout(element) {
  const {
    offsetWidth: width,
    offsetHeight: height
  } = element;
  const {
    x: offsetLeft,
    y: offsetTop
  } = getEdgeOffset(element, null);
  return {
    width,
    height,
    offsetTop,
    offsetLeft
  };
}
function getBoundingClientRect(element) {
  if (element instanceof Window) {
    const width2 = window.innerWidth;
    const height2 = window.innerHeight;
    return {
      top: 0,
      left: 0,
      right: width2,
      bottom: height2,
      width: width2,
      height: height2,
      offsetTop: 0,
      offsetLeft: 0
    };
  }
  const {
    offsetTop,
    offsetLeft
  } = getElementLayout(element);
  const {
    width,
    height,
    top,
    bottom,
    left,
    right
  } = element.getBoundingClientRect();
  return {
    width,
    height,
    top,
    bottom,
    right,
    left,
    offsetTop,
    offsetLeft
  };
}
function getViewRect(element) {
  const {
    width,
    height,
    offsetTop,
    offsetLeft
  } = getElementLayout(element);
  const scrollableAncestors = getScrollableAncestors(element);
  const scrollOffsets = getScrollOffsets(scrollableAncestors);
  const top = offsetTop - scrollOffsets.y;
  const left = offsetLeft - scrollOffsets.x;
  return {
    width,
    height,
    top,
    bottom: top + height,
    right: left + width,
    left,
    offsetTop,
    offsetLeft
  };
}
function isViewRect(entry) {
  return "top" in entry;
}
function cornersOfRectangle(rect, left = rect.offsetLeft, top = rect.offsetTop) {
  return [{
    x: left,
    y: top
  }, {
    x: left + rect.width,
    y: top
  }, {
    x: left,
    y: top + rect.height
  }, {
    x: left + rect.width,
    y: top + rect.height
  }];
}
var closestCorners = (entries, target) => {
  const corners = cornersOfRectangle(target, target.left, target.top);
  const distances = entries.map(([_, entry]) => {
    const entryCorners = cornersOfRectangle(entry, isViewRect(entry) ? entry.left : void 0, isViewRect(entry) ? entry.top : void 0);
    const distances2 = corners.reduce((accumulator, corner, index) => {
      return accumulator + distanceBetween(entryCorners[index], corner);
    }, 0);
    return Number((distances2 / 4).toFixed(4));
  });
  const minValueIndex = getMinValueIndex(distances);
  return entries[minValueIndex] ? entries[minValueIndex][0] : null;
};
function getIntersectionRatio(entry, target) {
  const top = Math.max(target.top, entry.offsetTop);
  const left = Math.max(target.left, entry.offsetLeft);
  const right = Math.min(target.left + target.width, entry.offsetLeft + entry.width);
  const bottom = Math.min(target.top + target.height, entry.offsetTop + entry.height);
  const width = right - left;
  const height = bottom - top;
  if (left < right && top < bottom) {
    const targetArea = target.width * target.height;
    const entryArea = entry.width * entry.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
}
var rectIntersection = (entries, target) => {
  const intersections = entries.map(([_, entry]) => getIntersectionRatio(entry, target));
  const maxValueIndex = getMaxValueIndex(intersections);
  if (intersections[maxValueIndex] <= 0) {
    return null;
  }
  return entries[maxValueIndex] ? entries[maxValueIndex][0] : null;
};
function getOwnerDocument(target) {
  return target instanceof HTMLElement ? target.ownerDocument : document;
}
function getWindow(target) {
  var _getOwnerDocument$def;
  return (_getOwnerDocument$def = getOwnerDocument(target).defaultView) != null ? _getOwnerDocument$def : window;
}
function getInitialState() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: {},
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: {}
    }
  };
}
function reducer(state, action) {
  switch (action.type) {
    case Action.DragStart:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          initialCoordinates: action.initialCoordinates,
          active: action.active
        }
      };
    case Action.DragMove:
      if (!state.draggable.active) {
        return state;
      }
      return {
        ...state,
        draggable: {
          ...state.draggable,
          translate: {
            x: action.coordinates.x - state.draggable.initialCoordinates.x,
            y: action.coordinates.y - state.draggable.initialCoordinates.y
          }
        }
      };
    case Action.DragEnd:
    case Action.DragCancel:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };
    case Action.RegisterDroppable: {
      const {
        element
      } = action;
      const {
        id
      } = element;
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers: {
            ...state.droppable.containers,
            [id]: element
          }
        }
      };
    }
    case Action.SetDroppableDisabled: {
      const {
        id,
        disabled
      } = action;
      const element = state.droppable.containers[id];
      if (!element) {
        return state;
      }
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers: {
            ...state.droppable.containers,
            [id]: {
              ...element,
              disabled
            }
          }
        }
      };
    }
    case Action.UnregisterDroppable: {
      const {
        id
      } = action;
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers: omit(id, state.droppable.containers)
        }
      };
    }
    default: {
      return state;
    }
  }
}
var DndMonitorContext = (0, import_react2.createContext)({
  type: null,
  event: null
});
function useDndMonitor({
  onDragStart,
  onDragMove,
  onDragOver,
  onDragEnd,
  onDragCancel
}) {
  const monitorState = (0, import_react2.useContext)(DndMonitorContext);
  const previousMonitorState = (0, import_react2.useRef)(monitorState);
  (0, import_react2.useEffect)(() => {
    if (monitorState !== previousMonitorState.current) {
      const {
        type,
        event
      } = monitorState;
      switch (type) {
        case Action.DragStart:
          onDragStart == null ? void 0 : onDragStart(event);
          break;
        case Action.DragMove:
          onDragMove == null ? void 0 : onDragMove(event);
          break;
        case Action.DragOver:
          onDragOver == null ? void 0 : onDragOver(event);
          break;
        case Action.DragCancel:
          onDragCancel == null ? void 0 : onDragCancel(event);
          break;
        case Action.DragEnd:
          onDragEnd == null ? void 0 : onDragEnd(event);
          break;
      }
      previousMonitorState.current = monitorState;
    }
  }, [monitorState, onDragStart, onDragMove, onDragOver, onDragEnd, onDragCancel]);
}
function Accessibility({
  announcements = defaultAnnouncements,
  hiddenTextDescribedById,
  screenReaderInstructions: screenReaderInstructions2
}) {
  const {
    announce,
    announcement
  } = useAnnouncement();
  const liveRegionId = useUniqueId(`DndLiveRegion`);
  const [mounted, setMounted] = (0, import_react2.useState)(false);
  (0, import_react2.useEffect)(() => {
    setMounted(true);
  }, []);
  useDndMonitor((0, import_react2.useMemo)(() => ({
    onDragStart({
      active
    }) {
      announce(announcements.onDragStart(active.id));
    },
    onDragMove({
      active,
      over
    }) {
      if (announcements.onDragMove) {
        announce(announcements.onDragMove(active.id, over == null ? void 0 : over.id));
      }
    },
    onDragOver({
      active,
      over
    }) {
      announce(announcements.onDragOver(active.id, over == null ? void 0 : over.id));
    },
    onDragEnd({
      active,
      over
    }) {
      announce(announcements.onDragEnd(active.id, over == null ? void 0 : over.id));
    },
    onDragCancel({
      active
    }) {
      announce(announcements.onDragCancel(active.id));
    }
  }), [announce, announcements]));
  return mounted ? (0, import_react_dom.createPortal)(import_react2.default.createElement(import_react2.default.Fragment, null, import_react2.default.createElement(HiddenText, {
    id: hiddenTextDescribedById,
    value: screenReaderInstructions2.draggable
  }), import_react2.default.createElement(LiveRegion, {
    id: liveRegionId,
    announcement
  })), document.body) : null;
}
var AutoScrollActivator;
(function(AutoScrollActivator2) {
  AutoScrollActivator2[AutoScrollActivator2["Pointer"] = 0] = "Pointer";
  AutoScrollActivator2[AutoScrollActivator2["DraggableRect"] = 1] = "DraggableRect";
})(AutoScrollActivator || (AutoScrollActivator = {}));
var TraversalOrder;
(function(TraversalOrder2) {
  TraversalOrder2[TraversalOrder2["TreeOrder"] = 0] = "TreeOrder";
  TraversalOrder2[TraversalOrder2["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
})(TraversalOrder || (TraversalOrder = {}));
function useAutoScroller({
  acceleration,
  activator = AutoScrollActivator.Pointer,
  canScroll,
  draggingRect,
  enabled,
  interval = 5,
  order = TraversalOrder.TreeOrder,
  pointerCoordinates,
  scrollableAncestors,
  scrollableAncestorRects,
  threshold
}) {
  const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
  const scrollSpeed = (0, import_react2.useRef)({
    x: 1,
    y: 1
  });
  const rect = (0, import_react2.useMemo)(() => {
    switch (activator) {
      case AutoScrollActivator.Pointer:
        return pointerCoordinates ? {
          top: pointerCoordinates.y,
          bottom: pointerCoordinates.y,
          left: pointerCoordinates.x,
          right: pointerCoordinates.x
        } : null;
      case AutoScrollActivator.DraggableRect:
        return draggingRect;
    }
    return null;
  }, [activator, draggingRect, pointerCoordinates]);
  const scrollDirection = (0, import_react2.useRef)(defaultCoordinates);
  const scrollContainerRef = (0, import_react2.useRef)(null);
  const autoScroll = (0, import_react2.useCallback)(() => {
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer) {
      return;
    }
    const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
    const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
    scrollContainer.scrollBy(scrollLeft, scrollTop);
  }, []);
  const sortedScrollableAncestors = (0, import_react2.useMemo)(() => order === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order, scrollableAncestors]);
  (0, import_react2.useEffect)(
    () => {
      if (!enabled || !scrollableAncestors.length || !rect) {
        clearAutoScrollInterval();
        return;
      }
      for (const scrollContainer of sortedScrollableAncestors) {
        if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
          continue;
        }
        const index = scrollableAncestors.indexOf(scrollContainer);
        const scrolllContainerRect = scrollableAncestorRects[index];
        if (!scrolllContainerRect) {
          continue;
        }
        const {
          direction,
          speed
        } = getScrollDirectionAndSpeed(scrollContainer, scrolllContainerRect, rect, acceleration, threshold);
        if (speed.x > 0 || speed.y > 0) {
          clearAutoScrollInterval();
          scrollContainerRef.current = scrollContainer;
          setAutoScrollInterval(autoScroll, interval);
          scrollSpeed.current = speed;
          scrollDirection.current = direction;
          return;
        }
      }
      scrollSpeed.current = {
        x: 0,
        y: 0
      };
      scrollDirection.current = {
        x: 0,
        y: 0
      };
      clearAutoScrollInterval();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      acceleration,
      autoScroll,
      canScroll,
      clearAutoScrollInterval,
      enabled,
      interval,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(rect),
      setAutoScrollInterval,
      scrollableAncestors,
      sortedScrollableAncestors,
      scrollableAncestorRects,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(threshold)
    ]
  );
}
function useCachedNode(draggableNodes, id) {
  const draggableNode = id !== null ? draggableNodes[id] : void 0;
  const node = draggableNode ? draggableNode.node.current : null;
  return useLazyMemo((cachedNode) => {
    var _ref;
    if (id === null) {
      return null;
    }
    return (_ref = node != null ? node : cachedNode) != null ? _ref : null;
  }, [node, id]);
}
function useCombineActivators(sensors, getSyntheticHandler) {
  return (0, import_react2.useMemo)(() => sensors.reduce((accumulator, sensor) => {
    const {
      sensor: Sensor
    } = sensor;
    const sensorActivators = Sensor.activators.map((activator) => ({
      eventName: activator.eventName,
      handler: getSyntheticHandler(activator.handler, sensor)
    }));
    return [...accumulator, ...sensorActivators];
  }, []), [sensors, getSyntheticHandler]);
}
function useData(data) {
  const dataRef = (0, import_react2.useRef)(data);
  useIsomorphicLayoutEffect(() => {
    if (dataRef.current !== data) {
      dataRef.current = data;
    }
  }, [data]);
  return dataRef;
}
var LayoutMeasuringStrategy;
(function(LayoutMeasuringStrategy2) {
  LayoutMeasuringStrategy2[LayoutMeasuringStrategy2["Always"] = 0] = "Always";
  LayoutMeasuringStrategy2[LayoutMeasuringStrategy2["BeforeDragging"] = 1] = "BeforeDragging";
  LayoutMeasuringStrategy2[LayoutMeasuringStrategy2["WhileDragging"] = 2] = "WhileDragging";
})(LayoutMeasuringStrategy || (LayoutMeasuringStrategy = {}));
var LayoutMeasuringFrequency;
(function(LayoutMeasuringFrequency2) {
  LayoutMeasuringFrequency2["Optimized"] = "optimized";
})(LayoutMeasuringFrequency || (LayoutMeasuringFrequency = {}));
var defaultValue = /* @__PURE__ */ new Map();
function useLayoutMeasuring(containers, {
  dragging,
  dependencies,
  config
}) {
  const [willRecomputeLayouts, setWillRecomputeLayouts] = (0, import_react2.useState)(false);
  const {
    frequency,
    strategy
  } = getLayoutMeasuring(config);
  const containersRef = (0, import_react2.useRef)(containers);
  const recomputeLayouts = (0, import_react2.useCallback)(() => setWillRecomputeLayouts(true), []);
  const recomputeLayoutsTimeoutId = (0, import_react2.useRef)(null);
  const disabled = isDisabled();
  const layoutRectMap = useLazyMemo((previousValue) => {
    if (disabled && !dragging) {
      return defaultValue;
    }
    if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || willRecomputeLayouts) {
      for (let container of Object.values(containers)) {
        if (!container) {
          continue;
        }
        container.rect.current = container.node.current ? getElementLayout(container.node.current) : null;
      }
      return createLayoutRectMap(containers);
    }
    return previousValue;
  }, [containers, dragging, disabled, willRecomputeLayouts]);
  (0, import_react2.useEffect)(() => {
    containersRef.current = containers;
  }, [containers]);
  (0, import_react2.useEffect)(() => {
    if (willRecomputeLayouts) {
      setWillRecomputeLayouts(false);
    }
  }, [willRecomputeLayouts]);
  (0, import_react2.useEffect)(
    function recompute() {
      if (disabled) {
        return;
      }
      requestAnimationFrame(recomputeLayouts);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [dragging, disabled]
  );
  (0, import_react2.useEffect)(
    function forceRecomputeLayouts() {
      if (disabled || typeof frequency !== "number" || recomputeLayoutsTimeoutId.current !== null) {
        return;
      }
      recomputeLayoutsTimeoutId.current = setTimeout(() => {
        recomputeLayouts();
        recomputeLayoutsTimeoutId.current = null;
      }, frequency);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [frequency, disabled, recomputeLayouts, ...dependencies]
  );
  return {
    layoutRectMap,
    recomputeLayouts,
    willRecomputeLayouts
  };
  function isDisabled() {
    switch (strategy) {
      case LayoutMeasuringStrategy.Always:
        return false;
      case LayoutMeasuringStrategy.BeforeDragging:
        return dragging;
      default:
        return !dragging;
    }
  }
}
function createLayoutRectMap(containers) {
  const layoutRectMap = /* @__PURE__ */ new Map();
  if (containers) {
    for (const container of Object.values(containers)) {
      if (!container) {
        continue;
      }
      const {
        id,
        rect,
        disabled
      } = container;
      if (disabled || rect.current == null) {
        continue;
      }
      layoutRectMap.set(id, rect.current);
    }
  }
  return layoutRectMap;
}
var defaultLayoutMeasuring = {
  strategy: LayoutMeasuringStrategy.WhileDragging,
  frequency: LayoutMeasuringFrequency.Optimized
};
function getLayoutMeasuring(layoutMeasuring) {
  return layoutMeasuring ? {
    ...defaultLayoutMeasuring,
    ...layoutMeasuring
  } : defaultLayoutMeasuring;
}
function useScrollOffsets(elements) {
  const [scrollCoordinates, setScrollCoordinates] = (0, import_react2.useState)(null);
  const prevElements = (0, import_react2.useRef)(elements);
  const handleScroll = (0, import_react2.useCallback)((event) => {
    const scrollingElement = getScrollableElement(event.target);
    if (!scrollingElement) {
      return;
    }
    setScrollCoordinates((scrollCoordinates2) => {
      if (!scrollCoordinates2) {
        return null;
      }
      scrollCoordinates2.set(scrollingElement, getScrollCoordinates(scrollingElement));
      return new Map(scrollCoordinates2);
    });
  }, []);
  (0, import_react2.useEffect)(() => {
    const previousElements = prevElements.current;
    if (elements !== previousElements) {
      cleanup(previousElements);
      const entries = elements.map((element) => {
        const scrollableElement = getScrollableElement(element);
        if (scrollableElement) {
          scrollableElement.addEventListener("scroll", handleScroll, {
            passive: true
          });
          return [scrollableElement, getScrollCoordinates(scrollableElement)];
        }
        return null;
      }).filter((entry) => entry != null);
      setScrollCoordinates(entries.length ? new Map(entries) : null);
      prevElements.current = elements;
    }
    return () => {
      cleanup(elements);
      cleanup(previousElements);
    };
    function cleanup(elements2) {
      elements2.forEach((element) => {
        const scrollableElement = getScrollableElement(element);
        scrollableElement == null ? void 0 : scrollableElement.removeEventListener("scroll", handleScroll);
      });
    }
  }, [handleScroll, elements]);
  return (0, import_react2.useMemo)(() => {
    if (elements.length) {
      return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
    }
    return defaultCoordinates;
  }, [elements, scrollCoordinates]);
}
var defaultValue$1 = [];
function useScrollableAncestors(node) {
  const previousNode = (0, import_react2.useRef)(node);
  const ancestors = useLazyMemo((previousValue) => {
    if (!node) {
      return defaultValue$1;
    }
    if (previousValue && node && previousNode.current && node.parentNode === previousNode.current.parentNode) {
      return previousValue;
    }
    return getScrollableAncestors(node);
  }, [node]);
  (0, import_react2.useEffect)(() => {
    previousNode.current = node;
  }, [node]);
  return ancestors;
}
function useSyntheticListeners(listeners, id) {
  return (0, import_react2.useMemo)(() => {
    return listeners.reduce((acc, {
      eventName,
      handler
    }) => {
      acc[eventName] = (event) => {
        handler(event, id);
      };
      return acc;
    }, {});
  }, [listeners, id]);
}
var useClientRect = createUseRectFn(getBoundingClientRect);
var useClientRects = createUseRectsFn(getBoundingClientRect);
var useViewRect = createUseRectFn(getViewRect);
function createUseRectFn(getRect) {
  return function useClientRect2(element, forceRecompute) {
    const previousElement = (0, import_react2.useRef)(element);
    return useLazyMemo((previousValue) => {
      if (!element) {
        return null;
      }
      if (forceRecompute || !previousValue && element || element !== previousElement.current) {
        if (element instanceof HTMLElement && element.parentNode == null) {
          return null;
        }
        return getRect(element);
      }
      return previousValue != null ? previousValue : null;
    }, [element, forceRecompute]);
  };
}
function createUseRectsFn(getRect) {
  const defaultValue2 = [];
  return function useRects(elements, forceRecompute) {
    const previousElements = (0, import_react2.useRef)(elements);
    return useLazyMemo((previousValue) => {
      if (!elements.length) {
        return defaultValue2;
      }
      if (forceRecompute || !previousValue && elements.length || elements !== previousElements.current) {
        return elements.map((element) => getRect(element));
      }
      return previousValue != null ? previousValue : defaultValue2;
    }, [elements, forceRecompute]);
  };
}
function useSensor(sensor, options) {
  return (0, import_react2.useMemo)(
    () => ({
      sensor,
      options: options != null ? options : {}
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [sensor, options]
  );
}
function useSensors(...sensors) {
  return (0, import_react2.useMemo)(
    () => [...sensors].filter((sensor) => sensor != null),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...sensors]
  );
}
var Listeners = class {
  constructor(target) {
    this.target = target;
    this.listeners = [];
  }
  add(eventName, handler, options) {
    this.target.addEventListener(eventName, handler, options);
    this.listeners.push({
      eventName,
      handler
    });
  }
  removeAll() {
    this.listeners.forEach(({
      eventName,
      handler
    }) => this.target.removeEventListener(eventName, handler));
  }
};
function getEventListenerTarget(element) {
  return element instanceof EventTarget ? element : getOwnerDocument(element);
}
function hasExceededDistance(delta, measurement) {
  const dx = Math.abs(delta.x);
  const dy = Math.abs(delta.y);
  if (typeof measurement === "number") {
    return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
  }
  if ("x" in measurement && "y" in measurement) {
    return dx > measurement.x && dy > measurement.y;
  }
  if ("x" in measurement) {
    return dx > measurement.x;
  }
  if ("y" in measurement) {
    return dy > measurement.y;
  }
  return false;
}
var KeyboardCode;
(function(KeyboardCode2) {
  KeyboardCode2["Space"] = "Space";
  KeyboardCode2["Down"] = "ArrowDown";
  KeyboardCode2["Right"] = "ArrowRight";
  KeyboardCode2["Left"] = "ArrowLeft";
  KeyboardCode2["Up"] = "ArrowUp";
  KeyboardCode2["Esc"] = "Escape";
  KeyboardCode2["Enter"] = "Enter";
})(KeyboardCode || (KeyboardCode = {}));
var defaultKeyboardCodes = {
  start: [KeyboardCode.Space, KeyboardCode.Enter],
  cancel: [KeyboardCode.Esc],
  end: [KeyboardCode.Space, KeyboardCode.Enter]
};
var defaultKeyboardCoordinateGetter = (event, {
  currentCoordinates
}) => {
  switch (event.code) {
    case KeyboardCode.Right:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x + 25
      };
    case KeyboardCode.Left:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x - 25
      };
    case KeyboardCode.Down:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y + 25
      };
    case KeyboardCode.Up:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y - 25
      };
  }
  return void 0;
};
var KeyboardSensor = class {
  constructor(props) {
    this.props = props;
    this.autoScrollEnabled = false;
    this.coordinates = defaultCoordinates;
    const {
      event: {
        target
      }
    } = props;
    this.props = props;
    this.listeners = new Listeners(getOwnerDocument(target));
    this.windowListeners = new Listeners(getWindow(target));
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.attach();
  }
  attach() {
    this.handleStart();
    setTimeout(() => {
      this.listeners.add("keydown", this.handleKeyDown);
      this.windowListeners.add("resize", this.handleCancel);
    });
  }
  handleStart() {
    const {
      activeNode,
      onStart
    } = this.props;
    if (!activeNode.node.current) {
      throw new Error("Active draggable node is undefined");
    }
    const activeNodeRect = getBoundingClientRect(activeNode.node.current);
    const coordinates = {
      x: activeNodeRect.left,
      y: activeNodeRect.top
    };
    this.coordinates = coordinates;
    onStart(coordinates);
  }
  handleKeyDown(event) {
    if (event instanceof KeyboardEvent) {
      const {
        coordinates
      } = this;
      const {
        active,
        context,
        options
      } = this.props;
      const {
        keyboardCodes = defaultKeyboardCodes,
        coordinateGetter = defaultKeyboardCoordinateGetter,
        scrollBehavior = "smooth"
      } = options;
      const {
        code
      } = event;
      if (keyboardCodes.end.includes(code)) {
        this.handleEnd(event);
        return;
      }
      if (keyboardCodes.cancel.includes(code)) {
        this.handleCancel(event);
        return;
      }
      const newCoordinates = coordinateGetter(event, {
        active,
        context: context.current,
        currentCoordinates: coordinates
      });
      if (newCoordinates) {
        const scrollDelta = {
          x: 0,
          y: 0
        };
        const {
          scrollableAncestors
        } = context.current;
        for (const scrollContainer of scrollableAncestors) {
          const direction = event.code;
          const coordinatesDelta = subtract(newCoordinates, coordinates);
          const {
            isTop,
            isRight,
            isLeft,
            isBottom,
            maxScroll,
            minScroll
          } = getScrollPosition(scrollContainer);
          const scrollElementRect = getScrollElementRect(scrollContainer);
          const clampedCoordinates = {
            x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
            y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
          };
          const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
          const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
          if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
            const canFullyScrollToNewCoordinates = direction === KeyboardCode.Right && scrollContainer.scrollLeft + coordinatesDelta.x <= maxScroll.x || direction === KeyboardCode.Left && scrollContainer.scrollLeft + coordinatesDelta.x >= minScroll.x;
            if (canFullyScrollToNewCoordinates) {
              scrollContainer.scrollBy({
                left: coordinatesDelta.x,
                behavior: scrollBehavior
              });
              return;
            }
            scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
            scrollContainer.scrollBy({
              left: -scrollDelta.x,
              behavior: scrollBehavior
            });
            break;
          } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
            const canFullyScrollToNewCoordinates = direction === KeyboardCode.Down && scrollContainer.scrollTop + coordinatesDelta.y <= maxScroll.y || direction === KeyboardCode.Up && scrollContainer.scrollTop + coordinatesDelta.y >= minScroll.y;
            if (canFullyScrollToNewCoordinates) {
              scrollContainer.scrollBy({
                top: coordinatesDelta.y,
                behavior: scrollBehavior
              });
              return;
            }
            scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
            scrollContainer.scrollBy({
              top: -scrollDelta.y,
              behavior: scrollBehavior
            });
            break;
          }
        }
        this.handleMove(event, add(newCoordinates, scrollDelta));
      }
    }
  }
  handleMove(event, coordinates) {
    const {
      onMove
    } = this.props;
    event.preventDefault();
    onMove(coordinates);
    this.coordinates = coordinates;
  }
  handleEnd(event) {
    const {
      onEnd
    } = this.props;
    event.preventDefault();
    this.detach();
    onEnd();
  }
  handleCancel(event) {
    const {
      onCancel
    } = this.props;
    event.preventDefault();
    this.detach();
    onCancel();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
  }
};
KeyboardSensor.activators = [{
  eventName: "onKeyDown",
  handler: (event, {
    keyboardCodes = defaultKeyboardCodes,
    onActivation
  }) => {
    const {
      code
    } = event.nativeEvent;
    if (keyboardCodes.start.includes(code)) {
      event.preventDefault();
      onActivation == null ? void 0 : onActivation({
        event: event.nativeEvent
      });
      return true;
    }
    return false;
  }
}];
function isDistanceConstraint(constraint) {
  return Boolean(constraint && "distance" in constraint);
}
function isDelayConstraint(constraint) {
  return Boolean(constraint && "delay" in constraint);
}
var EventName;
(function(EventName2) {
  EventName2["Keydown"] = "keydown";
})(EventName || (EventName = {}));
var AbstractPointerSensor = class {
  constructor(props, events2, listenerTarget = getEventListenerTarget(props.event.target)) {
    this.props = props;
    this.events = events2;
    this.autoScrollEnabled = true;
    this.activated = false;
    this.timeoutId = null;
    const {
      event
    } = props;
    this.props = props;
    this.events = events2;
    this.ownerDocument = getOwnerDocument(event.target);
    this.listeners = new Listeners(listenerTarget);
    this.initialCoordinates = getEventCoordinates(event);
    this.handleStart = this.handleStart.bind(this);
    this.handleMove = this.handleMove.bind(this);
    this.handleEnd = this.handleEnd.bind(this);
    this.handleKeydown = this.handleKeydown.bind(this);
    this.attach();
  }
  attach() {
    const {
      events: events2,
      props: {
        options: {
          activationConstraint
        }
      }
    } = this;
    this.listeners.add(events2.move.name, this.handleMove, false);
    this.listeners.add(events2.end.name, this.handleEnd);
    this.ownerDocument.addEventListener(EventName.Keydown, this.handleKeydown);
    if (activationConstraint) {
      if (isDistanceConstraint(activationConstraint)) {
        return;
      }
      if (isDelayConstraint(activationConstraint)) {
        this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll();
    this.ownerDocument.removeEventListener(EventName.Keydown, this.handleKeydown);
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  handleStart() {
    const {
      initialCoordinates
    } = this;
    const {
      onStart
    } = this.props;
    if (initialCoordinates) {
      this.activated = true;
      onStart(initialCoordinates);
    }
  }
  handleMove(event) {
    const {
      activated,
      initialCoordinates,
      props
    } = this;
    const {
      onMove,
      options: {
        activationConstraint
      }
    } = props;
    if (!initialCoordinates) {
      return;
    }
    const coordinates = getEventCoordinates(event);
    const delta = subtract(initialCoordinates, coordinates);
    if (!activated && activationConstraint) {
      if (isDelayConstraint(activationConstraint)) {
        if (hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
        return;
      }
      if (isDistanceConstraint(activationConstraint)) {
        if (hasExceededDistance(delta, activationConstraint.distance)) {
          return this.handleStart();
        }
        return;
      }
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    onMove(coordinates);
  }
  handleEnd() {
    const {
      onEnd
    } = this.props;
    this.detach();
    onEnd();
  }
  handleCancel() {
    const {
      onCancel
    } = this.props;
    this.detach();
    onCancel();
  }
  handleKeydown(event) {
    if (event.code === KeyboardCode.Esc) {
      this.handleCancel();
    }
  }
};
var events = {
  move: {
    name: "pointermove"
  },
  end: {
    name: "pointerup"
  }
};
var PointerSensor = class extends AbstractPointerSensor {
  constructor(props) {
    const {
      event
    } = props;
    const listenerTarget = getOwnerDocument(event.target);
    super(props, events, listenerTarget);
  }
};
PointerSensor.activators = [{
  eventName: "onPointerDown",
  handler: ({
    nativeEvent: event
  }, {
    onActivation
  }) => {
    if (!event.isPrimary || event.button !== 0) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
var events$1 = {
  move: {
    name: "mousemove"
  },
  end: {
    name: "mouseup"
  }
};
var MouseButton;
(function(MouseButton2) {
  MouseButton2[MouseButton2["RightClick"] = 2] = "RightClick";
})(MouseButton || (MouseButton = {}));
var MouseSensor = class extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$1, getOwnerDocument(props.event.target));
  }
};
MouseSensor.activators = [{
  eventName: "onMouseDown",
  handler: ({
    nativeEvent: event
  }, {
    onActivation
  }) => {
    if (event.button === MouseButton.RightClick) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
var events$2 = {
  move: {
    name: "touchmove"
  },
  end: {
    name: "touchend"
  }
};
var TouchSensor = class extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$2);
  }
};
TouchSensor.activators = [{
  eventName: "onTouchStart",
  handler: ({
    nativeEvent: event
  }, {
    onActivation
  }) => {
    const {
      touches
    } = event;
    if (touches.length > 1) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
function applyModifiers(modifiers, {
  transform,
  ...args
}) {
  return (modifiers == null ? void 0 : modifiers.length) ? modifiers.reduce((accumulator, modifier) => {
    return modifier({
      transform: accumulator,
      ...args
    });
  }, transform) : transform;
}
var defaultSensors = [{
  sensor: PointerSensor,
  options: {}
}, {
  sensor: KeyboardSensor,
  options: {}
}];
var defaultData = {
  current: {}
};
var ActiveDraggableContext = (0, import_react2.createContext)({
  ...defaultCoordinates,
  scaleX: 1,
  scaleY: 1
});
var DndContext = (0, import_react2.memo)(function DndContext2({
  id,
  autoScroll = true,
  announcements,
  children,
  sensors = defaultSensors,
  collisionDetection = rectIntersection,
  layoutMeasuring,
  modifiers,
  screenReaderInstructions: screenReaderInstructions$1 = screenReaderInstructions,
  ...props
}) {
  var _sensorContext$curren, _sensorContext$curren2, _overContainer$rect$c;
  const store = (0, import_react2.useReducer)(reducer, void 0, getInitialState);
  const [state, dispatch] = store;
  const [monitorState, setMonitorState] = (0, import_react2.useState)(() => ({
    type: null,
    event: null
  }));
  const {
    draggable: {
      active: activeId,
      nodes: draggableNodes,
      translate
    },
    droppable: {
      containers: droppableContainers
    }
  } = state;
  const node = activeId ? draggableNodes[activeId] : null;
  const activeRects = (0, import_react2.useRef)({
    initial: null,
    translated: null
  });
  const active = (0, import_react2.useMemo)(() => {
    var _node$data;
    return activeId != null ? {
      id: activeId,
      // It's possible for the active node to unmount while dragging
      data: (_node$data = node == null ? void 0 : node.data) != null ? _node$data : defaultData,
      rect: activeRects
    } : null;
  }, [activeId, node]);
  const activeRef = (0, import_react2.useRef)(null);
  const [activeSensor, setActiveSensor] = (0, import_react2.useState)(null);
  const [activatorEvent, setActivatorEvent] = (0, import_react2.useState)(null);
  const latestProps = (0, import_react2.useRef)(props);
  const draggableDescribedById = useUniqueId(`DndDescribedBy`, id);
  const {
    layoutRectMap: droppableRects,
    recomputeLayouts,
    willRecomputeLayouts
  } = useLayoutMeasuring(droppableContainers, {
    dragging: activeId != null,
    dependencies: [translate.x, translate.y],
    config: layoutMeasuring
  });
  const activeNode = useCachedNode(draggableNodes, activeId);
  const activationCoordinates = activatorEvent ? getEventCoordinates(activatorEvent) : null;
  const activeNodeRect = useViewRect(activeNode);
  const activeNodeClientRect = useClientRect(activeNode);
  const initialActiveNodeRectRef = (0, import_react2.useRef)(null);
  const initialActiveNodeRect = initialActiveNodeRectRef.current;
  const nodeRectDelta = getRectDelta(activeNodeRect, initialActiveNodeRect);
  const sensorContext = (0, import_react2.useRef)({
    active: null,
    activeNode,
    collisionRect: null,
    droppableRects,
    draggableNodes,
    draggingNodeRect: null,
    droppableContainers,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null,
    translatedRect: null
  });
  const overNode = getDroppableNode((_sensorContext$curren = (_sensorContext$curren2 = sensorContext.current.over) == null ? void 0 : _sensorContext$curren2.id) != null ? _sensorContext$curren : null, droppableContainers);
  const windowRect = useClientRect(activeNode ? activeNode.ownerDocument.defaultView : null);
  const containerNodeRect = useClientRect(activeNode ? activeNode.parentElement : null);
  const scrollableAncestors = useScrollableAncestors(activeId ? overNode != null ? overNode : activeNode : null);
  const scrollableAncestorRects = useClientRects(scrollableAncestors);
  const [overlayNodeRef, setOverlayNodeRef] = useNodeRef();
  const overlayNodeRect = useClientRect(activeId ? overlayNodeRef.current : null, willRecomputeLayouts);
  const draggingNodeRect = overlayNodeRect != null ? overlayNodeRect : activeNodeClientRect;
  const modifiedTranslate = applyModifiers(modifiers, {
    transform: {
      x: translate.x - nodeRectDelta.x,
      y: translate.y - nodeRectDelta.y,
      scaleX: 1,
      scaleY: 1
    },
    active,
    over: sensorContext.current.over,
    activeNodeRect: activeNodeClientRect,
    draggingNodeRect,
    containerNodeRect,
    overlayNodeRect,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect
  });
  const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
  const scrollAdjustment = useScrollOffsets(scrollableAncestors);
  const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
  const translatedRect = activeNodeRect ? getAdjustedRect(activeNodeRect, modifiedTranslate) : null;
  const collisionRect = translatedRect ? getAdjustedRect(translatedRect, scrollAdjustment) : null;
  const overId = active && collisionRect ? collisionDetection(Array.from(droppableRects.entries()), collisionRect) : null;
  const overContainer = getOver(overId, droppableContainers);
  const over = (0, import_react2.useMemo)(() => overContainer && overContainer.rect.current ? {
    id: overContainer.id,
    rect: overContainer.rect.current,
    data: overContainer.data,
    disabled: overContainer.disabled
  } : null, [overContainer]);
  const transform = adjustScale(modifiedTranslate, (_overContainer$rect$c = overContainer == null ? void 0 : overContainer.rect.current) != null ? _overContainer$rect$c : null, activeNodeRect);
  const instantiateSensor = (0, import_react2.useCallback)((event, {
    sensor: Sensor,
    options
  }) => {
    if (!activeRef.current) {
      return;
    }
    const activeNode2 = draggableNodes[activeRef.current];
    if (!activeNode2) {
      return;
    }
    const sensorInstance = new Sensor({
      active: activeRef.current,
      activeNode: activeNode2,
      event: event.nativeEvent,
      options,
      // Sensors need to be instantiated with refs for arguments that change over time
      // otherwise they are frozen in time with the stale arguments
      context: sensorContext,
      onStart(initialCoordinates) {
        const id2 = activeRef.current;
        if (!id2) {
          return;
        }
        const node2 = draggableNodes[id2];
        if (!node2) {
          return;
        }
        const {
          onDragStart
        } = latestProps.current;
        const event2 = {
          active: {
            id: id2,
            data: node2.data,
            rect: activeRects
          }
        };
        dispatch({
          type: Action.DragStart,
          initialCoordinates,
          active: id2
        });
        setMonitorState({
          type: Action.DragStart,
          event: event2
        });
        onDragStart == null ? void 0 : onDragStart(event2);
      },
      onMove(coordinates) {
        dispatch({
          type: Action.DragMove,
          coordinates
        });
      },
      onEnd: createHandler(Action.DragEnd),
      onCancel: createHandler(Action.DragCancel)
    });
    setActiveSensor(sensorInstance);
    setActivatorEvent(event.nativeEvent);
    function createHandler(type) {
      return async function handler() {
        const {
          active: active2,
          over: over2,
          scrollAdjustedTranslate: scrollAdjustedTranslate2
        } = sensorContext.current;
        let event2 = null;
        if (active2 && scrollAdjustedTranslate2) {
          const {
            cancelDrop
          } = latestProps.current;
          event2 = {
            active: active2,
            delta: scrollAdjustedTranslate2,
            over: over2
          };
          if (type === Action.DragEnd && typeof cancelDrop === "function") {
            const shouldCancel = await Promise.resolve(cancelDrop(event2));
            if (shouldCancel) {
              type = Action.DragCancel;
            }
          }
        }
        activeRef.current = null;
        dispatch({
          type
        });
        setActiveSensor(null);
        setActivatorEvent(null);
        if (event2) {
          const {
            onDragCancel,
            onDragEnd
          } = latestProps.current;
          const handler2 = type === Action.DragEnd ? onDragEnd : onDragCancel;
          setMonitorState({
            type,
            event: event2
          });
          handler2 == null ? void 0 : handler2(event2);
        }
      };
    }
  }, [dispatch, draggableNodes]);
  const bindActivatorToSensorInstantiator = (0, import_react2.useCallback)((handler, sensor) => {
    return (event, active2) => {
      const nativeEvent = event.nativeEvent;
      if (// No active draggable
      activeRef.current !== null || // Event has already been captured
      nativeEvent.dndKit || nativeEvent.defaultPrevented) {
        return;
      }
      if (handler(event, sensor.options) === true) {
        nativeEvent.dndKit = {
          capturedBy: sensor.sensor
        };
        activeRef.current = active2;
        instantiateSensor(event, sensor);
      }
    };
  }, [instantiateSensor]);
  const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
  useIsomorphicLayoutEffect(
    () => {
      latestProps.current = props;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Object.values(props)
  );
  (0, import_react2.useEffect)(() => {
    if (!active) {
      initialActiveNodeRectRef.current = null;
    }
    if (active && activeNodeRect && !initialActiveNodeRectRef.current) {
      initialActiveNodeRectRef.current = activeNodeRect;
    }
  }, [activeNodeRect, active]);
  (0, import_react2.useEffect)(() => {
    const {
      onDragMove
    } = latestProps.current;
    const {
      active: active2,
      over: over2
    } = sensorContext.current;
    if (!active2) {
      return;
    }
    const event = {
      active: active2,
      delta: {
        x: scrollAdjustedTranslate.x,
        y: scrollAdjustedTranslate.y
      },
      over: over2
    };
    setMonitorState({
      type: Action.DragMove,
      event
    });
    onDragMove == null ? void 0 : onDragMove(event);
  }, [scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]);
  (0, import_react2.useEffect)(
    () => {
      const {
        active: active2,
        scrollAdjustedTranslate: scrollAdjustedTranslate2
      } = sensorContext.current;
      if (!active2 || !activeRef.current || !scrollAdjustedTranslate2) {
        return;
      }
      const {
        onDragOver
      } = latestProps.current;
      const event = {
        active: active2,
        delta: {
          x: scrollAdjustedTranslate2.x,
          y: scrollAdjustedTranslate2.y
        },
        over
      };
      setMonitorState({
        type: Action.DragOver,
        event
      });
      onDragOver == null ? void 0 : onDragOver(event);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [over == null ? void 0 : over.id]
  );
  useIsomorphicLayoutEffect(() => {
    sensorContext.current = {
      active,
      activeNode,
      collisionRect,
      droppableRects,
      draggableNodes,
      draggingNodeRect,
      droppableContainers,
      over,
      scrollableAncestors,
      scrollAdjustedTranslate,
      translatedRect
    };
    activeRects.current = {
      initial: draggingNodeRect,
      translated: translatedRect
    };
  }, [active, activeNode, collisionRect, draggableNodes, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate, translatedRect]);
  useAutoScroller({
    ...getAutoScrollerOptions(),
    draggingRect: translatedRect,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects
  });
  const contextValue = (0, import_react2.useMemo)(() => {
    const memoizedContext = {
      active,
      activeNode,
      activeNodeRect,
      activeNodeClientRect,
      activatorEvent,
      activators,
      ariaDescribedById: {
        draggable: draggableDescribedById
      },
      overlayNode: {
        nodeRef: overlayNodeRef,
        rect: overlayNodeRect,
        setRef: setOverlayNodeRef
      },
      containerNodeRect,
      dispatch,
      draggableNodes,
      droppableContainers,
      droppableRects,
      over,
      recomputeLayouts,
      scrollableAncestors,
      scrollableAncestorRects,
      willRecomputeLayouts,
      windowRect
    };
    return memoizedContext;
  }, [active, activeNode, activeNodeClientRect, activeNodeRect, activatorEvent, activators, containerNodeRect, overlayNodeRect, overlayNodeRef, dispatch, draggableNodes, draggableDescribedById, droppableContainers, droppableRects, over, recomputeLayouts, scrollableAncestors, scrollableAncestorRects, setOverlayNodeRef, willRecomputeLayouts, windowRect]);
  return import_react2.default.createElement(DndMonitorContext.Provider, {
    value: monitorState
  }, import_react2.default.createElement(Context.Provider, {
    value: contextValue
  }, import_react2.default.createElement(ActiveDraggableContext.Provider, {
    value: transform
  }, children)), import_react2.default.createElement(Accessibility, {
    announcements,
    hiddenTextDescribedById: draggableDescribedById,
    screenReaderInstructions: screenReaderInstructions$1
  }));
  function getAutoScrollerOptions() {
    const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
    const autoScrollGloballyDisabled = typeof autoScroll === "object" ? autoScroll.enabled === false : autoScroll === false;
    const enabled = !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
    if (typeof autoScroll === "object") {
      return {
        ...autoScroll,
        enabled
      };
    }
    return {
      enabled
    };
  }
});
function getDroppableNode(id, droppableContainers) {
  var _droppableContainers$, _droppableContainers$2;
  return id ? (_droppableContainers$ = (_droppableContainers$2 = droppableContainers[id]) == null ? void 0 : _droppableContainers$2.node.current) != null ? _droppableContainers$ : null : null;
}
function getOver(id, droppableContainers) {
  var _droppableContainers$3;
  return id ? (_droppableContainers$3 = droppableContainers[id]) != null ? _droppableContainers$3 : null : null;
}
var NullContext = (0, import_react2.createContext)(null);
var defaultRole = "button";
function useDraggable({
  id,
  data,
  disabled = false,
  attributes
}) {
  const {
    active,
    activeNodeRect,
    activatorEvent,
    ariaDescribedById,
    draggableNodes,
    droppableRects,
    activators,
    over
  } = (0, import_react2.useContext)(Context);
  const {
    role = defaultRole,
    roleDescription = "draggable",
    tabIndex = 0
  } = attributes != null ? attributes : {};
  const isDragging = (active == null ? void 0 : active.id) === id;
  const transform = (0, import_react2.useContext)(isDragging ? ActiveDraggableContext : NullContext);
  const [node, setNodeRef] = useNodeRef();
  const listeners = useSyntheticListeners(activators, id);
  const dataRef = useData(data);
  (0, import_react2.useEffect)(
    () => {
      draggableNodes[id] = {
        node,
        data: dataRef
      };
      return () => {
        delete draggableNodes[id];
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [draggableNodes, id]
  );
  const memoizedAttributes = (0, import_react2.useMemo)(() => ({
    role,
    tabIndex,
    "aria-pressed": isDragging && role === defaultRole ? true : void 0,
    "aria-roledescription": roleDescription,
    "aria-describedby": ariaDescribedById.draggable
  }), [role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
  return {
    active,
    activeNodeRect,
    activatorEvent,
    attributes: memoizedAttributes,
    droppableRects,
    isDragging,
    listeners: disabled ? void 0 : listeners,
    node,
    over,
    setNodeRef,
    transform
  };
}
function useDndContext() {
  return (0, import_react2.useContext)(Context);
}
function useDroppable({
  data,
  disabled = false,
  id
}) {
  const {
    active,
    dispatch,
    over
  } = (0, import_react2.useContext)(Context);
  const rect = (0, import_react2.useRef)(null);
  const [nodeRef, setNodeRef] = useNodeRef();
  const dataRef = useData(data);
  useIsomorphicLayoutEffect(
    () => {
      dispatch({
        type: Action.RegisterDroppable,
        element: {
          id,
          disabled,
          node: nodeRef,
          rect,
          data: dataRef
        }
      });
      return () => dispatch({
        type: Action.UnregisterDroppable,
        id
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [id]
  );
  (0, import_react2.useEffect)(
    () => {
      dispatch({
        type: Action.SetDroppableDisabled,
        id,
        disabled
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [disabled]
  );
  return {
    active,
    rect,
    isOver: (over == null ? void 0 : over.id) === id,
    node: nodeRef,
    over,
    setNodeRef
  };
}
function useDerivedTransform(transform, rect, overlayNode) {
  const prevRect = (0, import_react2.useRef)(rect);
  return useLazyMemo((previousValue) => {
    const initial = prevRect.current;
    if (rect !== initial) {
      if (rect && initial) {
        const layoutHasChanged = initial.left !== rect.left || initial.top !== rect.top;
        if (layoutHasChanged && !previousValue) {
          const overlayNodeRect = overlayNode == null ? void 0 : overlayNode.getBoundingClientRect();
          if (overlayNodeRect) {
            const delta = {
              ...transform,
              x: overlayNodeRect.left - rect.left,
              y: overlayNodeRect.top - rect.top
            };
            return delta;
          }
        }
      }
      prevRect.current = rect;
    }
    return void 0;
  }, [rect, transform, overlayNode]);
}
function useDropAnimation({
  animate,
  adjustScale: adjustScale2,
  activeId,
  draggableNodes,
  duration,
  easing,
  dragSourceOpacity,
  node,
  transform
}) {
  const [dropAnimationComplete, setDropAnimationComplete] = (0, import_react2.useState)(false);
  (0, import_react2.useEffect)(() => {
    if (!animate || !activeId || !easing || !duration) {
      if (animate) {
        setDropAnimationComplete(true);
      }
      return;
    }
    requestAnimationFrame(() => {
      var _draggableNodes$activ;
      const finalNode = (_draggableNodes$activ = draggableNodes[activeId]) == null ? void 0 : _draggableNodes$activ.node.current;
      if (transform && node && finalNode && finalNode.parentNode !== null) {
        const fromNode = node.children.length > 1 ? node : node.children[0];
        if (fromNode) {
          const from = fromNode.getBoundingClientRect();
          const to = getViewRect(finalNode);
          const delta = {
            x: from.left - to.left,
            y: from.top - to.top
          };
          if (Math.abs(delta.x) || Math.abs(delta.y)) {
            const scaleDelta = {
              scaleX: adjustScale2 ? to.width * transform.scaleX / from.width : 1,
              scaleY: adjustScale2 ? to.height * transform.scaleY / from.height : 1
            };
            const finalTransform = CSS.Transform.toString({
              x: transform.x - delta.x,
              y: transform.y - delta.y,
              ...scaleDelta
            });
            const originalOpacity = finalNode.style.opacity;
            if (dragSourceOpacity != null) {
              finalNode.style.opacity = `${dragSourceOpacity}`;
            }
            const nodeAnimation = node.animate([{
              transform: CSS.Transform.toString(transform)
            }, {
              transform: finalTransform
            }], {
              easing,
              duration
            });
            nodeAnimation.onfinish = () => {
              node.style.display = "none";
              setDropAnimationComplete(true);
              if (finalNode && dragSourceOpacity != null) {
                finalNode.style.opacity = originalOpacity;
              }
            };
            return;
          }
        }
      }
      setDropAnimationComplete(true);
    });
  }, [animate, activeId, adjustScale2, draggableNodes, duration, easing, dragSourceOpacity, node, transform]);
  useIsomorphicLayoutEffect(() => {
    if (dropAnimationComplete) {
      setDropAnimationComplete(false);
    }
  }, [dropAnimationComplete]);
  return dropAnimationComplete;
}
var defaultTransition = (activatorEvent) => {
  const isKeyboardActivator = activatorEvent instanceof KeyboardEvent;
  return isKeyboardActivator ? "transform 250ms ease" : void 0;
};
var defaultDropAnimation = {
  duration: 250,
  easing: "ease",
  dragSourceOpacity: 0
};
var DragOverlay = import_react2.default.memo(({
  adjustScale: adjustScale2 = false,
  children,
  dropAnimation = defaultDropAnimation,
  style: styleProp,
  transition = defaultTransition,
  modifiers,
  wrapperElement = "div",
  className,
  zIndex = 999
}) => {
  var _active$id, _attributesSnapshot$c;
  const {
    active,
    activeNodeRect,
    activeNodeClientRect,
    containerNodeRect,
    draggableNodes,
    activatorEvent,
    over,
    overlayNode,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect
  } = useDndContext();
  const transform = (0, import_react2.useContext)(ActiveDraggableContext);
  const modifiedTransform = applyModifiers(modifiers, {
    active,
    activeNodeRect: activeNodeClientRect,
    draggingNodeRect: overlayNode.rect,
    containerNodeRect,
    over,
    overlayNodeRect: overlayNode.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    transform,
    windowRect
  });
  const derivedTransform = useDerivedTransform(modifiedTransform, activeNodeRect, overlayNode.nodeRef.current);
  const isDragging = active !== null;
  const intermediateTransform = derivedTransform != null ? derivedTransform : modifiedTransform;
  const finalTransform = adjustScale2 ? intermediateTransform : {
    ...intermediateTransform,
    scaleX: 1,
    scaleY: 1
  };
  const style = activeNodeRect ? {
    position: "fixed",
    width: activeNodeRect.width,
    height: activeNodeRect.height,
    top: activeNodeRect.top,
    left: activeNodeRect.left,
    zIndex,
    transform: CSS.Transform.toString(finalTransform),
    touchAction: "none",
    transformOrigin: adjustScale2 && activatorEvent ? getRelativeTransformOrigin(activatorEvent, activeNodeRect) : void 0,
    transition: derivedTransform ? void 0 : typeof transition === "function" ? transition(activatorEvent) : transition,
    ...styleProp
  } : void 0;
  const attributes = isDragging ? {
    style,
    children,
    className,
    transform: finalTransform
  } : void 0;
  const attributesSnapshot = (0, import_react2.useRef)(attributes);
  const derivedAttributes = attributes != null ? attributes : attributesSnapshot.current;
  const {
    children: finalChildren,
    transform: _,
    ...otherAttributes
  } = derivedAttributes != null ? derivedAttributes : {};
  const prevActiveId = (0, import_react2.useRef)((_active$id = active == null ? void 0 : active.id) != null ? _active$id : null);
  const dropAnimationComplete = useDropAnimation({
    animate: Boolean(dropAnimation && prevActiveId.current && !active),
    adjustScale: adjustScale2,
    activeId: prevActiveId.current,
    draggableNodes,
    duration: dropAnimation == null ? void 0 : dropAnimation.duration,
    easing: dropAnimation == null ? void 0 : dropAnimation.easing,
    dragSourceOpacity: dropAnimation == null ? void 0 : dropAnimation.dragSourceOpacity,
    node: overlayNode.nodeRef.current,
    transform: (_attributesSnapshot$c = attributesSnapshot.current) == null ? void 0 : _attributesSnapshot$c.transform
  });
  const shouldRender = Boolean(finalChildren && (children || dropAnimation && !dropAnimationComplete));
  (0, import_react2.useEffect)(() => {
    if ((active == null ? void 0 : active.id) !== prevActiveId.current) {
      var _active$id2;
      prevActiveId.current = (_active$id2 = active == null ? void 0 : active.id) != null ? _active$id2 : null;
    }
    if (active && attributesSnapshot.current !== attributes) {
      attributesSnapshot.current = attributes;
    }
  }, [active, attributes]);
  (0, import_react2.useEffect)(() => {
    if (dropAnimationComplete) {
      attributesSnapshot.current = void 0;
    }
  }, [dropAnimationComplete]);
  if (!shouldRender) {
    return null;
  }
  return import_react2.default.createElement(wrapperElement, {
    ...otherAttributes,
    ref: overlayNode.setRef
  }, finalChildren);
});

export {
  defaultAnnouncements,
  defaultCoordinates,
  closestCenter,
  getScrollableAncestors,
  getBoundingClientRect,
  getViewRect,
  closestCorners,
  rectIntersection,
  useDndMonitor,
  AutoScrollActivator,
  TraversalOrder,
  LayoutMeasuringStrategy,
  LayoutMeasuringFrequency,
  useSensor,
  useSensors,
  KeyboardCode,
  KeyboardSensor,
  PointerSensor,
  MouseSensor,
  TouchSensor,
  applyModifiers,
  DndContext,
  useDraggable,
  useDndContext,
  useDroppable,
  defaultDropAnimation,
  DragOverlay
};
//# sourceMappingURL=chunk-IPKCGN4A.js.map
