{
  "version": 3,
  "sources": ["../../@dnd-kit/sortable/src/utilities/arrayMove.ts", "../../@dnd-kit/sortable/src/utilities/getSortedRects.ts", "../../@dnd-kit/sortable/src/utilities/isValidIndex.ts", "../../@dnd-kit/sortable/src/strategies/horizontalListSorting.ts", "../../@dnd-kit/sortable/src/strategies/rectSorting.ts", "../../@dnd-kit/sortable/src/strategies/rectSwapping.ts", "../../@dnd-kit/sortable/src/strategies/verticalListSorting.ts", "../../@dnd-kit/sortable/src/components/SortableContext.tsx", "../../@dnd-kit/sortable/src/hooks/defaults.ts", "../../@dnd-kit/sortable/src/hooks/utilities/useDerivedTransform.ts", "../../@dnd-kit/sortable/src/hooks/useSortable.ts", "../../@dnd-kit/sortable/src/sensors/keyboard/sortableKeyboardCoordinates.ts"],
  "sourcesContent": ["/**\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\n */\nexport function arrayMove<T>(array: T[], from: number, to: number): T[] {\n  const newArray = array.slice();\n  newArray.splice(\n    to < 0 ? newArray.length + to : to,\n    0,\n    newArray.splice(from, 1)[0]\n  );\n\n  return newArray;\n}\n", "import type {\n  LayoutRect,\n  UniqueIdentifier,\n  UseDndContextReturnValue,\n} from '@dnd-kit/core';\n\nexport function getSortedRects(\n  items: UniqueIdentifier[],\n  layoutRects: UseDndContextReturnValue['droppableRects']\n) {\n  return items.reduce<LayoutRect[]>((accumulator, id, index) => {\n    const layoutRect = layoutRects.get(id);\n\n    if (layoutRect) {\n      accumulator[index] = layoutRect;\n    }\n\n    return accumulator;\n  }, Array(items.length));\n}\n", "export function isValidIndex(index: number | null): index is number {\n  return index !== null && index >= 0;\n}\n", "import type {LayoutRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const horizontalListSortingStrategy: SortingStrategy = ({\n  layoutRects,\n  activeNodeRect: fallbackActiveRect,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const activeNodeRect = layoutRects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  const itemGap = getItemGap(layoutRects, index, activeIndex);\n\n  if (index === activeIndex) {\n    const newIndexRect = layoutRects[overIndex];\n\n    if (!newIndexRect) {\n      return null;\n    }\n\n    return {\n      x:\n        activeIndex < overIndex\n          ? newIndexRect.offsetLeft +\n            newIndexRect.width -\n            (activeNodeRect.offsetLeft + activeNodeRect.width)\n          : newIndexRect.offsetLeft - activeNodeRect.offsetLeft,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: -activeNodeRect.width - itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: activeNodeRect.width + itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  layoutRects: LayoutRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect = layoutRects[index];\n  const previousRect = layoutRects[index - 1];\n  const nextRect = layoutRects[index + 1];\n\n  if (!previousRect && !nextRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width)\n      : nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width);\n  }\n\n  return nextRect\n    ? nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width)\n    : currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width);\n}\n", "import {arrayMove} from '../utilities';\nimport type {SortingStrategy} from '../types';\n\nexport const rectSortingStrategy: SortingStrategy = ({\n  layoutRects,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const newRects = arrayMove(layoutRects, overIndex, activeIndex);\n\n  const oldRect = layoutRects[index];\n  const newRect = newRects[index];\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n", "import type {SortingStrategy} from '../types';\n\nexport const rectSwappingStrategy: SortingStrategy = ({\n  activeIndex,\n  index,\n  layoutRects,\n  overIndex,\n}) => {\n  let oldRect;\n  let newRect;\n\n  if (index === activeIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[overIndex];\n  }\n\n  if (index === overIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[activeIndex];\n  }\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n", "import type {LayoutRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const verticalListSortingStrategy: SortingStrategy = ({\n  activeIndex,\n  activeNodeRect: fallbackActiveRect,\n  index,\n  layoutRects,\n  overIndex,\n}) => {\n  const activeNodeRect = layoutRects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  if (index === activeIndex) {\n    const overIndexRect = layoutRects[overIndex];\n\n    if (!overIndexRect) {\n      return null;\n    }\n\n    return {\n      x: 0,\n      y:\n        activeIndex < overIndex\n          ? overIndexRect.offsetTop +\n            overIndexRect.height -\n            (activeNodeRect.offsetTop + activeNodeRect.height)\n          : overIndexRect.offsetTop - activeNodeRect.offsetTop,\n      ...defaultScale,\n    };\n  }\n\n  const itemGap = getItemGap(layoutRects, index, activeIndex);\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: 0,\n      y: -activeNodeRect.height - itemGap,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: 0,\n      y: activeNodeRect.height + itemGap,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  layoutRects: LayoutRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect = layoutRects[index];\n  const previousRect = layoutRects[index - 1];\n  const nextRect = layoutRects[index + 1];\n\n  if (!currentRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height)\n      : nextRect\n      ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height)\n      : 0;\n  }\n\n  return nextRect\n    ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height)\n    : previousRect\n    ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height)\n    : 0;\n}\n", "import React, {MutableRefObject, useEffect, useMemo, useRef} from 'react';\nimport {useDndContext, LayoutRect, UniqueIdentifier} from '@dnd-kit/core';\nimport {useIsomorphicLayoutEffect, useUniqueId} from '@dnd-kit/utilities';\n\nimport type {SortingStrategy} from '../types';\nimport {getSortedRects} from '../utilities';\nimport {rectSortingStrategy} from '../strategies';\n\nexport interface Props {\n  children: React.ReactNode;\n  items: (UniqueIdentifier | {id: UniqueIdentifier})[];\n  strategy?: SortingStrategy;\n  id?: string;\n}\n\nconst ID_PREFIX = 'Sortable';\n\ninterface ContextDescriptor {\n  activeIndex: number;\n  containerId: string;\n  disableTransforms: boolean;\n  items: UniqueIdentifier[];\n  overIndex: number;\n  useDragOverlay: boolean;\n  sortedRects: LayoutRect[];\n  strategy: SortingStrategy;\n  wasSorting: MutableRefObject<boolean>;\n}\n\nexport const Context = React.createContext<ContextDescriptor>({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n  wasSorting: {current: false},\n});\n\nexport function SortableContext({\n  children,\n  id,\n  items: userDefinedItems,\n  strategy = rectSortingStrategy,\n}: Props) {\n  const {\n    active,\n    overlayNode,\n    droppableRects,\n    over,\n    recomputeLayouts,\n    willRecomputeLayouts,\n  } = useDndContext();\n  const containerId = useUniqueId(ID_PREFIX, id);\n  const useDragOverlay = Boolean(overlayNode.rect !== null);\n  const items = useMemo(\n    () =>\n      userDefinedItems.map((item) =>\n        typeof item === 'string' ? item : item.id\n      ),\n    [userDefinedItems]\n  );\n  const activeIndex = active ? items.indexOf(active.id) : -1;\n  const isSorting = activeIndex !== -1;\n  const wasSorting = useRef(isSorting);\n  const overIndex = over ? items.indexOf(over.id) : -1;\n  const previousItemsRef = useRef(items);\n  const sortedRects = getSortedRects(items, droppableRects);\n  const itemsHaveChanged = !isEqual(items, previousItemsRef.current);\n  const disableTransforms =\n    (overIndex !== -1 && activeIndex === -1) || itemsHaveChanged;\n\n  useIsomorphicLayoutEffect(() => {\n    if (itemsHaveChanged && isSorting && !willRecomputeLayouts) {\n      // To-do: Add partial recompution of only subset of rects\n      recomputeLayouts();\n    }\n  }, [itemsHaveChanged, isSorting, recomputeLayouts, willRecomputeLayouts]);\n\n  useEffect(() => {\n    previousItemsRef.current = items;\n  }, [items]);\n\n  useEffect(() => {\n    requestAnimationFrame(() => {\n      wasSorting.current = isSorting;\n    });\n  }, [isSorting]);\n\n  const contextValue = useMemo(\n    (): ContextDescriptor => ({\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      useDragOverlay,\n      sortedRects,\n      strategy,\n      wasSorting,\n    }),\n    [\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      sortedRects,\n      useDragOverlay,\n      strategy,\n      wasSorting,\n    ]\n  );\n\n  return <Context.Provider value={contextValue}>{children}</Context.Provider>;\n}\n\nfunction isEqual(arr1: string[], arr2: string[]) {\n  return arr1.join() === arr2.join();\n}\n", "import {CSS} from '@dnd-kit/utilities';\n\nimport type {AnimateLayoutChanges, SortableTransition} from './types';\n\nexport const defaultAnimateLayoutChanges: AnimateLayoutChanges = ({\n  isSorting,\n  index,\n  newIndex,\n  transition,\n}) => {\n  if (!transition) {\n    return false;\n  }\n\n  if (isSorting) {\n    return true;\n  }\n\n  return newIndex !== index;\n};\n\nexport const defaultTransition: SortableTransition = {\n  duration: 200,\n  easing: 'ease',\n};\n\nexport const transitionProperty = 'transform';\n\nexport const disabledTransition = CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear',\n});\n\nexport const defaultAttributes = {\n  roleDescription: 'sortable',\n};\n", "import {useEffect, useRef, useState} from 'react';\nimport {getBoundingClientRect, LayoutRect} from '@dnd-kit/core';\nimport type {Transform} from '@dnd-kit/utilities';\n\ninterface Arguments {\n  rect: React.MutableRefObject<LayoutRect | null>;\n  disabled: boolean;\n  index: number;\n  node: React.MutableRefObject<HTMLElement | null>;\n}\n\n/*\n * When the index of an item changes while sorting,\n * we need to temporarily disable the transforms\n */\nexport function useDerivedTransform({rect, disabled, index, node}: Arguments) {\n  const [derivedTransform, setDerivedtransform] = useState<Transform | null>(\n    null\n  );\n  const prevIndex = useRef(index);\n\n  useEffect(() => {\n    if (!disabled && index !== prevIndex.current && node.current) {\n      const initial = rect.current;\n\n      if (initial) {\n        const current = getBoundingClientRect(node.current);\n        const delta = {\n          x: initial.offsetLeft - current.offsetLeft,\n          y: initial.offsetTop - current.offsetTop,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height,\n        };\n\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n\n    if (index !== prevIndex.current) {\n      prevIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n\n  useEffect(() => {\n    if (derivedTransform) {\n      requestAnimationFrame(() => {\n        setDerivedtransform(null);\n      });\n    }\n  }, [derivedTransform]);\n\n  return derivedTransform;\n}\n", "import {useContext, useEffect, useMemo, useRef} from 'react';\nimport {useDraggable, useDroppable, UseDraggableArguments} from '@dnd-kit/core';\nimport {CSS, useCombinedRefs} from '@dnd-kit/utilities';\n\nimport {Context} from '../components';\nimport type {SortingStrategy} from '../types';\nimport {arrayMove, isValidIndex} from '../utilities';\nimport {\n  defaultAnimateLayoutChanges,\n  defaultAttributes,\n  defaultTransition,\n  disabledTransition,\n  transitionProperty,\n} from './defaults';\nimport type {AnimateLayoutChanges, SortableTransition} from './types';\nimport {useDerivedTransform} from './utilities';\n\nexport interface Arguments extends UseDraggableArguments {\n  animateLayoutChanges?: AnimateLayoutChanges;\n  strategy?: SortingStrategy;\n  transition?: SortableTransition | null;\n}\n\nexport function useSortable({\n  animateLayoutChanges = defaultAnimateLayoutChanges,\n  attributes: userDefinedAttributes,\n  disabled,\n  data: customData,\n  id,\n  strategy: localStrategy,\n  transition = defaultTransition,\n}: Arguments) {\n  const {\n    items,\n    containerId,\n    activeIndex,\n    disableTransforms,\n    sortedRects,\n    overIndex,\n    useDragOverlay,\n    strategy: globalStrategy,\n    wasSorting,\n  } = useContext(Context);\n  const index = items.indexOf(id);\n  const data = useMemo(\n    () => ({sortable: {containerId, index, items}, ...customData}),\n    [containerId, customData, index, items]\n  );\n  const {rect, node, setNodeRef: setDroppableNodeRef} = useDroppable({\n    id,\n    data,\n  });\n  const {\n    active,\n    activeNodeRect,\n    activatorEvent,\n    attributes,\n    setNodeRef: setDraggableNodeRef,\n    listeners,\n    isDragging,\n    over,\n    transform,\n  } = useDraggable({\n    id,\n    data,\n    attributes: {\n      ...defaultAttributes,\n      ...userDefinedAttributes,\n    },\n    disabled,\n  });\n  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  const isSorting = Boolean(active);\n  const displaceItem =\n    isSorting &&\n    wasSorting.current &&\n    !disableTransforms &&\n    isValidIndex(activeIndex) &&\n    isValidIndex(overIndex);\n  const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  const dragSourceDisplacement =\n    shouldDisplaceDragSource && displaceItem ? transform : null;\n  const strategy = localStrategy ?? globalStrategy;\n  const finalTransform = displaceItem\n    ? dragSourceDisplacement ??\n      strategy({\n        layoutRects: sortedRects,\n        activeNodeRect,\n        activeIndex,\n        overIndex,\n        index,\n      })\n    : null;\n  const newIndex =\n    isValidIndex(activeIndex) && isValidIndex(overIndex)\n      ? arrayMove(items, activeIndex, overIndex).indexOf(id)\n      : index;\n  const prevNewIndex = useRef(newIndex);\n  const shouldAnimateLayoutChanges = animateLayoutChanges({\n    active,\n    isDragging,\n    isSorting,\n    id,\n    index,\n    items,\n    newIndex: prevNewIndex.current,\n    transition,\n    wasSorting: wasSorting.current,\n  });\n  const derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index,\n    node,\n    rect,\n  });\n\n  useEffect(() => {\n    if (isSorting) {\n      prevNewIndex.current = newIndex;\n    }\n  }, [isSorting, newIndex]);\n\n  return {\n    active,\n    attributes,\n    activatorEvent,\n    rect,\n    index,\n    isSorting,\n    isDragging,\n    listeners,\n    node,\n    overIndex,\n    over,\n    setNodeRef,\n    setDroppableNodeRef,\n    setDraggableNodeRef,\n    transform: derivedTransform ?? finalTransform,\n    transition: getTransition(),\n  };\n\n  function getTransition() {\n    if (derivedTransform) {\n      // Temporarily disable transitions for a single frame to set up derived transforms\n      return disabledTransition;\n    }\n\n    if (shouldDisplaceDragSource || !transition) {\n      return null;\n    }\n\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString({\n        ...transition,\n        property: transitionProperty,\n      });\n    }\n\n    return null;\n  }\n}\n", "import {\n  closestCorners,\n  getViewRect,\n  getScrollableAncestors,\n  KeyboardCode,\n  RectEntry,\n  KeyboardCoordinateGetter,\n} from '@dnd-kit/core';\n\nconst directions: string[] = [\n  KeyboardCode.Down,\n  KeyboardCode.Right,\n  KeyboardCode.Up,\n  KeyboardCode.Left,\n];\n\nexport const sortableKeyboardCoordinates: KeyboardCoordinateGetter = (\n  event,\n  {context: {droppableContainers, translatedRect, scrollableAncestors}}\n) => {\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n\n    if (!translatedRect) {\n      return;\n    }\n\n    const layoutRects: RectEntry[] = [];\n\n    Object.entries(droppableContainers).forEach(([id, container]) => {\n      if (container?.disabled) {\n        return;\n      }\n\n      const node = container?.node.current;\n\n      if (!node) {\n        return;\n      }\n\n      const rect = getViewRect(node);\n\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (translatedRect.top + translatedRect.height <= rect.top) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Up:\n          if (translatedRect.top >= rect.top + rect.height) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Left:\n          if (translatedRect.left >= rect.left + rect.width) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Right:\n          if (translatedRect.left + translatedRect.width <= rect.left) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n      }\n    });\n\n    const closestId = closestCorners(layoutRects, translatedRect);\n\n    if (closestId) {\n      const newNode = droppableContainers[closestId]?.node.current;\n\n      if (newNode) {\n        const newScrollAncestors = getScrollableAncestors(newNode);\n        const hasDifferentScrollAncestors = newScrollAncestors.some(\n          (element, index) => scrollableAncestors[index] !== element\n        );\n        const newRect = getViewRect(newNode);\n        const offset = hasDifferentScrollAncestors\n          ? {\n              x: 0,\n              y: 0,\n            }\n          : {\n              x: translatedRect.width - newRect.width,\n              y: translatedRect.height - newRect.height,\n            };\n        const newCoordinates = {\n          x: newRect.left - offset.x,\n          y: newRect.top - offset.y,\n        };\n\n        return newCoordinates;\n      }\n    }\n  }\n\n  return undefined;\n};\n"],
  "mappings": "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",
  "names": ["arrayMove", "array", "from", "to", "newArray", "slice", "splice", "length", "getSortedRects", "items", "layoutRects", "reduce", "accumulator", "id", "index", "layoutRect", "get", "Array", "isValidIndex", "defaultScale", "scaleX", "scaleY", "horizontalListSortingStrategy", "activeNodeRect", "fallbackActiveRect", "activeIndex", "overIndex", "itemGap", "getItemGap", "newIndexRect", "x", "offsetLeft", "width", "y", "currentRect", "previousRect", "nextRect", "rectSortingStrategy", "newRects", "oldRect", "newRect", "offsetTop", "height", "rectSwappingStrategy", "verticalListSortingStrategy", "overIndexRect", "ID_PREFIX", "Context", "React", "createContext", "containerId", "disableTransforms", "useDragOverlay", "sortedRects", "strategy", "wasSorting", "current", "SortableContext", "children", "userDefinedItems", "active", "overlayNode", "droppableRects", "over", "recomputeLayouts", "willRecomputeLayouts", "useDndContext", "useUniqueId", "Boolean", "rect", "useMemo", "map", "item", "indexOf", "isSorting", "useRef", "previousItemsRef", "itemsHaveChanged", "isEqual", "useIsomorphicLayoutEffect", "useEffect", "requestAnimationFrame", "contextValue", "Provider", "value", "arr1", "arr2", "join", "defaultAnimateLayoutChanges", "newIndex", "transition", "defaultTransition", "duration", "easing", "transitionProperty", "disabledTransition", "CSS", "Transition", "toString", "property", "defaultAttributes", "roleDescription", "useDerivedTransform", "disabled", "node", "derivedTransform", "setDerivedtransform", "useState", "prevIndex", "initial", "getBoundingClientRect", "delta", "useSortable", "animateLayoutChanges", "attributes", "userDefinedAttributes", "data", "customData", "localStrategy", "globalStrategy", "useContext", "sortable", "setNodeRef", "setDroppableNodeRef", "useDroppable", "activatorEvent", "setDraggableNodeRef", "listeners", "isDragging", "transform", "useDraggable", "useCombinedRefs", "displaceItem", "shouldDisplaceDragSource", "dragSourceDisplacement", "finalTransform", "prevNewIndex", "shouldAnimateLayoutChanges", "getTransition", "directions", "KeyboardCode", "Down", "Right", "Up", "Left", "sortableKeyboardCoordinates", "event", "context", "droppableContainers", "translatedRect", "scrollableAncestors", "includes", "code", "preventDefault", "Object", "entries", "forEach", "container", "getViewRect", "top", "push", "left", "closestId", "closestCorners", "newNode", "newScrollAncestors", "getScrollableAncestors", "hasDifferentScrollAncestors", "some", "element", "offset", "newCoordinates", "undefined"]
}
